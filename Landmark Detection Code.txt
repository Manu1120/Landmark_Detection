import numpy as np
import pandas as pd
import keras
import cv2
from matplotlib import pyplot as plt
import os
import random
from PIL import Image
!pip install numpy==1.26.4
!pip uninstall opencv-python -y
!pip install "opencv-python<4.8.0"
import warnings
warnings.filterwarnings("ignore", category=FutureWarning)
df = pd.read_csv("train.csv")
base_path = "./images/"
df
samples = 20000
df = df.loc[df["id"].str.startswith('00', na=False), :]
num_classes = len(df["landmark_id"].unique())
num_datanum_classes = len(df)
num_classes
num_data
data = pd.DataFrame(df["landmark_id"].value_counts())
data.reset_index(inplace=True)
data.head()
data.tail()
data.columns = ['landmark_id','count']
data['count'].describe()
plt.hist(data['landmark_id'], 100, range = (0, 3843), label = 'test')
data['count'].between(0,5).sum()
data['count'].between(5,10).sum()
plt.hist(df["landmark_id"], bins=np.sort(df["landmark_id"].unique()))
plt.xlabel("Landmark ID")
plt.ylabel("Count")
plt.show()
from sklearn.preprocessing import LabelEncoder
lencoder = LabelEncoder()
lencoder.fit(df["landmark_id"])
df.head()
def encode_label(lb1):
    return lencoder.transform(lb1)
def decode_label(lb1):
    return lencoder.inverse_transform(lb1)
def get_image_from_number(num, dataframe):
    fname = dataframe.iloc[num]["id"] + '.jpg'
    label = dataframe.iloc[num]["landmark_id"]
    img_path = os.path.join('./images', fname)

    image = cv2.imread(img_path)
    if image is None:
        # Skip missing images by returning None
        return None, None
    
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    return image, label
print("4 Sample images from random classes")
fig = plt.figure(figsize=(16,16))
for i in range(1,5):
    ri = random.choices(os.listdir(base_path), k=3)
    folder = base_path + '/' + ri[0] + '/' +ri[1] + '/' +ri[2]
    random_img = random.choice(os.listdir(folder))
    img = np.array(Image.open(folder+'/'+random_img))
    fig.add_subplot(1,4,i)
    plt.imshow(img)
    plt.axis('off')
    plt.show()
import tensorflow as tf
from keras.applications.vgg19 import VGG19
from keras.layers import *
from keras import Sequential
learning_rate = 0.0001
decay_speed = 1e-6
momentum = 0.09
loss_function = "sparse_categorical_crossentropy"
source_model = VGG19(weights=None)
drop_layer = Dropout(0.5)
drop_layer2 = Dropout(0.5)
model = Sequential()
for layer in source_model.layers[:-1]:
    if layer == source_model.layers[-25]:
        model.add(BatchNormalization())
    model.add(layer)
model.add(Dense(num_classes, activation = "softmax"))
model.summary()
from keras.optimizers import RMSprop
optim1 = RMSprop(learning_rate=learning_rate)
model.compile(optimizer=optim1,
              loss=loss_function,
              metrics = ["accuracy"])
def image_reshape(im, target_size):
    return cv2.resize(im, target_size)
def get_batch(dataframe, start, batch_size):
    image_array = []
    label_array = []
    end_img = min(start + batch_size, len(dataframe))

    for idx in range(start, end_img):
        im, label = get_image_from_number(idx, dataframe)

        # Skip if image is missing
        if im is None:
            continue

        im = image_reshape(im, (224, 224)) / 255.0
        image_array.append(im)
        label_array.append(label)

    # Return empty arrays if no images were loaded in this batch
    if len(image_array) == 0:
        return np.array([]), np.array([])

    return np.array(image_array), np.array(label_array)
batch_size = 16
epoch_shuffle = True
weight_classes = True
epochs = 1

train, val = np.split(df.sample(frac=1),[int(0.8*len(df))])
print(len(train))
print(len(val))
# Training loop - fixed
for e in range(epochs):
    print(f"Epoch: {e+1}/{epochs}")
    
    if epoch_shuffle:
        train = train.sample(frac=1).reset_index(drop=True)
    
    num_batches = int(np.ceil(len(train) / batch_size))
    for it in range(num_batches):
        X_train, y_train_raw = get_batch(train, it * batch_size, batch_size)

        # Skip empty batches (e.g., all missing images)
        if X_train.shape[0] == 0:
            continue

        # Encode labels to integers
        y_train = encode_label(y_train_raw)

        # Train on this batch
        loss, acc = model.train_on_batch(X_train, y_train)

        if it % 10 == 0:
            print(f"  Batch {it+1}/{num_batches}  Loss: {loss:.4f}  Acc: {acc:.4f}")

# Save trained model
model.save("Model.keras")
print("Model saved successfully.")
errors = 0
bad_preds = []
good_preds = []

for it in range(int(np.ceil(len(val) / batch_size))):
    X_val, y_val = get_batch(val, it * batch_size, batch_size)

    # Skip empty batches
    if X_val.shape[0] == 0:
        continue

    result = model.predict(X_val, verbose=0)  # verbose=0 disables progress bar
    cla = np.argmax(result, axis=1)

    for idx, res in enumerate(result):
        index_in_data = batch_size * it + idx
        if cla[idx] != y_val[idx]:
            errors += 1
            bad_preds.append((index_in_data, cla[idx], res[cla[idx]]))
        else:
            good_preds.append((index_in_data, cla[idx], res[cla[idx]]))

print(f"Total Errors: {errors}")
print(f"Accuracy: {(1 - errors / len(val)) * 100:.2f}%")

# Show some correct predictions
for i in range(min(5, len(good_preds))):
    n = good_preds[i][0]
    img, lb1 = get_image_from_number(n, val)
    if img is not None:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        plt.figure()
        plt.imshow(img)
        plt.title(f"Predicted: {decode_label([good_preds[i][1]])[0]}")
        plt.axis('off')
        plt.show()
